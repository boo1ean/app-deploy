#!/usr/bin/env node

var _ = require('lodash');
var minimatch = require('minimatch');
var path = require('path');
var fs = require('fs');
var realist = require('realist');
var table = require('text-table');
var shell = require('../lib/shell');
var u = require('../lib/utils');
var sprintf = require('util').format;

var Configstore = require('configstore');
var Storage = require('../lib/storage');
var Matcher = require('../lib/matcher');
var Config = require('../lib/config');

var configPath = path.resolve('app-deploy.json');

try {
	var config  = new Config(configPath);
	var conf    = new Configstore(configPath);
	var storage = new Storage(conf);
} catch (e) {
	handleError(e);
}

var commands = {
	'default': usage,
	'remote add <name> <url>': addRemote,
	'remote rm <name>': removeRemote,
	'remote ls': listRemotes,
	'deploy local': localDeploy,
	'deploy <remote>': remoteDeploy
};

function usage () {
	u.info(fs.readFileSync(__dirname + '/usage.txt').toString());
}

function addRemote (opts, name, url) {

	var tokens = url.split(':');
	var connectionString = tokens[0];
	var workingPath = tokens[1];

	var remote = {
		connectionString: connectionString,
		path: workingPath,
		env: opts.env || ''
	};

	validateRemote(connectionString, workingPath);
	storage.saveRemote(name, remote);

	function validateRemote (connectionString, workingPath) {
		if (!connectionString) {
			u.halt('Please specify remote connection string');
		}

		if (!workingPath) {
			u.halt('Please specify remote working path');
		}
	}

}

function listRemotes () {
	var remotes = storage.getRemotes();

	if (_.isEmpty(remotes)) {
		u.halt('There are no remotes');
	}

	remotes = _.map(remotes, function (remote, name) {
		return [name, remote.connectionString, remote.path, remote.env];
	});

	u.info(table(remotes));
}

function removeRemote (opts, name) {
	storage.removeRemoteByName(name);
	u.info('Successfully removed remote "' + name + '"');
}

function remoteDeploy (opts, remoteName) {
	var remote = storage.getRemoteUrlByName(remoteName);
	var flags = [];

	if (!remote) {
		u.halt('Remote ' + remoteName + ' not found');
	}

	if (opts.dryRun) {
		flags.push('--dry-run');
	}

	if (opts.head) {
		flags.push('--head ' + opts.head);
	}

	var cmd = sprintf(
		'ssh %s \'%s; cd %s; git pull; ./node_modules/.bin/ad deploy local %s\'',
		remote.connectionString, remote.env, remote.path, flags.join(' ')
	);

	var result = shell.exec(cmd);
	u.info(result.output);
};

function localDeploy (opts) {
	if (isGitRepoMissing()) {
		u.halt('Git repository not found');
	}

	var matcher = new Matcher(minimatch);

	var recentDeployHash = storage.getRecentDeployHash();
	var headHash = opts.head || shell.getHeadHash();

	var commands;

	if (isEverythingDeployed(recentDeployHash, headHash)) {
		throw new Error('Nothing to deploy');
	}

	if (didNotDeployYet(recentDeployHash)) {
		return matcher.findInitialTriggersToExecute(config.triggers).then(runCommands);
	} else {
		// Get list of changed files
		var files = shell.getChangedFilesBetween(recentDeployHash, headHash);

		// Changed files info
		u.info('Changed files:');
		u.info(files.join('\n'), '\n');

		// Get list of commands to execute according to changed files
		matcher.findTriggersToExecute(config.triggers, files).then(runCommands);
	}

	function runCommands (commands) {
		if (opts.dryRun) {
			dryRun(commands);
		} else {
			run(commands);
		}
	}

	function dryRun (commands) {
		u.info('Commands to be executed:');
		u.info(commands.join('\n'));
	}

	function run (commands) {
		// Execute commands
		shell.executeCommands(commands);

		// Save deploy to completed deploys array
		storage.saveDeployInfo({ startHash: recentDeployHash, endHash: headHash, commands: commands });

		u.info('Successfully deployed!');
	}

	function isGitRepoMissing () {
		try {
			shell.exec('git st');
			return false;
		} catch (e) {
			return true;
		}
	}

	function didNotDeployYet (hash) {
		return !hash;
	}

	function isEverythingDeployed (left, right) {
		return left === right;
	}
}

function handleError (e) {
	u.halt(e.message);
}

var options = {
	'dryRun': ['dry-run', 'dry'],
	'head': ['head', 'head-hash']
};

try {
	realist(commands, options);
} catch (e) {
	handleError(e);
}

#!/usr/bin/env node

var Promise = require('bluebird');
var _ = require('lodash');
var minimatch = require('minimatch');
var path = require('path');
var fs = require('fs');
var realist = require('realist');
var table = require('text-table');
var shell = require('../lib/shell');
var u = require('../lib/utils');

var Configstore = require('configstore');
var Storage = require('../lib/storage');
var Matcher = require('../lib/matcher');
var Config = require('../lib/config');

var configPath = path.resolve('app-deploy.json');

try {
	var config  = new Config(configPath);
	var conf    = new Configstore(configPath);
	var storage = new Storage(conf);
} catch (e) {
	handleError(e);
}

var commands = {
	'default': usage,
	'remote add <name> <url>': addRemote,
	'remote rm <name>': removeRemote,
	'remote ls': listRemotes,
	'deploy local': deploy,
	'deploy <remote>': remoteDeploy
};

function remoteDeploy (opts, remote) {
	var url = storage.getRemoteUrlByName(remote);

	if (!url) {
		u.halt('Remote ' + remote + ' not found');
	}

	var cmd = 'ssh ' + url.connectionString + ' \'cd ' + url.path + '; ad deploy local\'';
	var result = shell.exec(cmd);
	u.info(result.output);
};

function usage () {
	u.info(fs.readFileSync(__dirname + '/usage.txt').toString());
}

function addRemote (opts, name, url) {

	var tokens = url.split(':');
	var connectionString = tokens[0];
	var workingPath = tokens[1];

	validateRemote(connectionString, workingPath);
	storage.saveRemote(name, { connectionString: connectionString, path: workingPath });

	function validateRemote (connectionString, workingPath) {
		if (!connectionString) {
			u.halt('Please specify remote connection string');
		}

		if (!workingPath) {
			u.halt('Please specify remote working path');
		}
	}

}

function listRemotes () {
	var remotes = storage.getRemotes();

	if (_.isEmpty(remotes)) {
		u.halt('There are no remotes');
	}

	remotes = _.map(remotes, function (remote, name) {
		return [name, remote.connectionString, remote.path];
	});

	u.info(table(remotes));
}

function removeRemote (opts, name) {
	storage.removeRemoteByName(name);
	u.info('Successfully removed remote "' + name + '"');
}

function deploy (opts) {
	if (isGitRepoMissing()) {
		u.halt('Git repository not found');
	}

	var matcher = new Matcher(minimatch);

	Promise.all([
		storage.getRecentDeployHash(),
		shell.getHeadHash()
	]).spread(function (recentDeployHash, headHash) {
		var commands;

		if (isEverythingDeployed(recentDeployHash, headHash)) {
			throw new Error('Nothing to deploy');
		}

		if (didNotDeployYet(recentDeployHash)) {
			commands = matcher.findInitialTriggersToExecute(config.triggers);
		} else {
			// Get list of changed files
			var files = shell.getChangedFilesBetween(recentDeployHash, headHash);

			// Changed files info
			u.info('Changed files:');
			u.info(files.join('\n'), '\n');

			// Get list of commands to execute according to changed files
			commands = matcher.findTriggersToExecute(config.triggers, files);
		}

		// Execute commands
		shell.executeCommands(commands);

		// Save deploy to completed deploys array
		storage.saveDeployInfo({ hash: headHash, commands: commands });

		u.info('Successfully deployed!');
	}).catch(handleError);

	function isGitRepoMissing () {
		try {
			shell.exec('git st');
			return false;
		} catch (e) {
			return true;
		}
	}

	function didNotDeployYet (hash) {
		return !hash;
	}

	function isEverythingDeployed (left, right) {
		return left === right;
	}
}

function handleError (e) {
	u.halt(e.message);
}

try {
	realist(commands);
} catch (e) {
	handleError(e);
}
